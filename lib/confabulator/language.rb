# Autogenerated from a Treetop grammar. Edits may be lost.


module Confabulator
	module ConfabulatorLanguage
   include Treetop::Runtime

   def root
     @root ||= :sentence
   end

   module Sentence0
				def confabulate(kb = nil)
					elements.map {|e| e.confabulate(kb) }.join
				end
				
				def tree(kb = nil)
				  elements.map { |e| e.tree(kb) }
			  end
   end

   def _nt_sentence
     start_index = index
     if node_cache[:sentence].has_key?(index)
       cached = node_cache[:sentence][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     s0, i0 = [], index
     loop do
       i1 = index
       r2 = _nt_protected
       if r2
         r1 = r2
       else
         r3 = _nt_substitution
         if r3
           r1 = r3
         else
           r4 = _nt_choice
           if r4
             r1 = r4
           else
             r5 = _nt_escaped_char
             if r5
               r1 = r5
             else
               r6 = _nt_words
               if r6
                 r1 = r6
               else
                 @index = i1
                 r1 = nil
               end
             end
           end
         end
       end
       if r1
         s0 << r1
       else
         break
       end
     end
     if s0.empty?
       @index = i0
       r0 = nil
     else
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Sentence0)
     end

     node_cache[:sentence][start_index] = r0

     r0
   end

   module Choice0
     def weight
       elements[0]
     end

     def sentence
       elements[1]
     end
   end

   module Choice1
     def weight
       elements[1]
     end

     def sentence_or_empty
       elements[2]
     end
   end

   module Choice2
     def first_sentence
       elements[1]
     end

     def rest_sentences
       elements[2]
     end

   end

   module Choice3
	   	  def choices(kb, no_weighting = false)
	   	    elems = []
					((no_weighting || first_sentence.weight.empty?) ? 1 : first_sentence.weight.value).times { elems << first_sentence.sentence }
					rest_sentences.elements.each do |s|
						((no_weighting || s.weight.empty?) ? 1 : s.weight.value).times { elems << s.sentence_or_empty }
					end
					elems
				end

				def confabulate(kb = nil)
				  elems = choices(kb)
				  elems[elems.length * rand].confabulate(kb)
				end

				def tree(kb = nil)
				  elems = choices(kb, true)
				  { :choices => elems.map {|e| Confabulator::Parser.remove_singleton_arrays(e.tree(kb)) } }
				end
   end

   def _nt_choice
     start_index = index
     if node_cache[:choice].has_key?(index)
       cached = node_cache[:choice][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     i0, s0 = index, []
     if has_terminal?('{', false, index)
       r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
       @index += 1
     else
       terminal_parse_failure('{')
       r1 = nil
     end
     s0 << r1
     if r1
       i2, s2 = index, []
       r4 = _nt_weight
       if r4
         r3 = r4
       else
         r3 = instantiate_node(SyntaxNode,input, index...index)
       end
       s2 << r3
       if r3
         r5 = _nt_sentence
         s2 << r5
       end
       if s2.last
         r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
         r2.extend(Choice0)
       else
         @index = i2
         r2 = nil
       end
       s0 << r2
       if r2
         s6, i6 = [], index
         loop do
           i7, s7 = index, []
           if has_terminal?('|', false, index)
             r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
             @index += 1
           else
             terminal_parse_failure('|')
             r8 = nil
           end
           s7 << r8
           if r8
             r10 = _nt_weight
             if r10
               r9 = r10
             else
               r9 = instantiate_node(SyntaxNode,input, index...index)
             end
             s7 << r9
             if r9
               i11 = index
               r12 = _nt_sentence
               if r12
                 r11 = r12
               else
                 r13 = _nt_empty
                 if r13
                   r11 = r13
                 else
                   @index = i11
                   r11 = nil
                 end
               end
               s7 << r11
             end
           end
           if s7.last
             r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
             r7.extend(Choice1)
           else
             @index = i7
             r7 = nil
           end
           if r7
             s6 << r7
           else
             break
           end
         end
         r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
         s0 << r6
         if r6
           if has_terminal?('}', false, index)
             r14 = instantiate_node(SyntaxNode,input, index...(index + 1))
             @index += 1
           else
             terminal_parse_failure('}')
             r14 = nil
           end
           s0 << r14
         end
       end
     end
     if s0.last
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Choice2)
       r0.extend(Choice3)
     else
       @index = i0
       r0 = nil
     end

     node_cache[:choice][start_index] = r0

     r0
   end

   module Empty0
		    def confabulate(kb = nil)
		      ''
		    end

				def tree(kb = nil)
				  confabulate(kb)
				end
   end

   def _nt_empty
     start_index = index
     if node_cache[:empty].has_key?(index)
       cached = node_cache[:empty][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     if has_terminal?('', false, index)
       r0 = instantiate_node(SyntaxNode,input, index...(index + 0))
       r0.extend(Empty0)
       @index += 0
     else
       terminal_parse_failure('')
       r0 = nil
     end

     node_cache[:empty][start_index] = r0

     r0
   end

   module Weight0
     def w
       elements[0]
     end

   end

   module Weight1
				def value
					w.text_value.to_i
				end
   end

   def _nt_weight
     start_index = index
     if node_cache[:weight].has_key?(index)
       cached = node_cache[:weight][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     i0, s0 = index, []
     s1, i1 = [], index
     loop do
       if has_terminal?('\G[0-9]', true, index)
         r2 = true
         @index += 1
       else
         r2 = nil
       end
       if r2
         s1 << r2
       else
         break
       end
     end
     if s1.empty?
       @index = i1
       r1 = nil
     else
       r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
     end
     s0 << r1
     if r1
       if has_terminal?(':', false, index)
         r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
         @index += 1
       else
         terminal_parse_failure(':')
         r3 = nil
       end
       s0 << r3
     end
     if s0.last
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Weight0)
       r0.extend(Weight1)
     else
       @index = i0
       r0 = nil
     end

     node_cache[:weight][start_index] = r0

     r0
   end

   module Protected0
   end

   module Protected1
     def words
       elements[1]
     end

   end

   module Protected2
				def confabulate(kb = nil)
					words.elements.map { |element|
						element.text_value == "\\`" ? "`" : element.text_value
					}.join
				end

				def tree(kb = nil)
				  confabulate(kb)
				end
   end

   def _nt_protected
     start_index = index
     if node_cache[:protected].has_key?(index)
       cached = node_cache[:protected][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     i0, s0 = index, []
     if has_terminal?("``", false, index)
       r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
       @index += 2
     else
       terminal_parse_failure("``")
       r1 = nil
     end
     s0 << r1
     if r1
       s2, i2 = [], index
       loop do
         i3 = index
         i4, s4 = index, []
         if has_terminal?("`", false, index)
           r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
           @index += 1
         else
           terminal_parse_failure("`")
           r5 = nil
         end
         s4 << r5
         if r5
           if has_terminal?('\G[^`]', true, index)
             r6 = true
             @index += 1
           else
             r6 = nil
           end
           s4 << r6
         end
         if s4.last
           r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
           r4.extend(Protected0)
         else
           @index = i4
           r4 = nil
         end
         if r4
           r3 = r4
         else
           if has_terminal?('\G[^`]', true, index)
             r7 = true
             @index += 1
           else
             r7 = nil
           end
           if r7
             r3 = r7
           else
             @index = i3
             r3 = nil
           end
         end
         if r3
           s2 << r3
         else
           break
         end
       end
       if s2.empty?
         @index = i2
         r2 = nil
       else
         r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
       end
       s0 << r2
       if r2
         if has_terminal?("``", false, index)
           r8 = instantiate_node(SyntaxNode,input, index...(index + 2))
           @index += 2
         else
           terminal_parse_failure("``")
           r8 = nil
         end
         s0 << r8
       end
     end
     if s0.last
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Protected1)
       r0.extend(Protected2)
     else
       @index = i0
       r0 = nil
     end

     node_cache[:protected][start_index] = r0

     r0
   end

   module Substitution0
   end

   module Substitution1
   end

   module Substitution2
     def w1
       elements[2]
     end

     def name
       elements[3]
     end

     def w2
       elements[4]
     end

     def options
       elements[5]
     end

     def w3
       elements[6]
     end

   end

   module Substitution3
				def confabulate(kb = nil)
					if kb
						result = kb.find(name.text_value).confabulate
						if options.text_value =~ /p/
							result = result.en.plural
						end
						if options.text_value =~ /c/
							result[0] = result[0].upcase if result[0]
						end
						result
					else
						""
					end
				end

				def tree(kb = nil)
				if kb
					results = kb.find(name.text_value).tree
					if options.text_value =~ /p/
     # results = Confabulator::Parser.expand(results).map { |r| r.en.plural }
					  results = { :pluralize => results }
					end
					if options.text_value =~ /c/
     # results = Confabulator::Parser.expand(results)
     #               results.each do |r|
     #                 r[0] = r[0].upcase if r[0]
     #               end
					  results = { :capitalize => results }
					end
					results
				else
					""
				end
				end
   end

   def _nt_substitution
     start_index = index
     if node_cache[:substitution].has_key?(index)
       cached = node_cache[:substitution][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     i0, s0 = index, []
     i1 = index
     if has_terminal?('\\\\', false, index)
       r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
       @index += 2
     else
       terminal_parse_failure('\\\\')
       r2 = nil
     end
     if r2
       r1 = nil
     else
       @index = i1
       r1 = instantiate_node(SyntaxNode,input, index...index)
     end
     s0 << r1
     if r1
       if has_terminal?('[', false, index)
         r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
         @index += 1
       else
         terminal_parse_failure('[')
         r3 = nil
       end
       s0 << r3
       if r3
         r4 = _nt_w
         s0 << r4
         if r4
           i5, s5 = index, []
           if has_terminal?('\G[a-zA-Z]', true, index)
             r6 = true
             @index += 1
           else
             r6 = nil
           end
           s5 << r6
           if r6
             s7, i7 = [], index
             loop do
               if has_terminal?('\G[a-zA-Z_0-9-]', true, index)
                 r8 = true
                 @index += 1
               else
                 r8 = nil
               end
               if r8
                 s7 << r8
               else
                 break
               end
             end
             r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
             s5 << r7
           end
           if s5.last
             r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
             r5.extend(Substitution0)
           else
             @index = i5
             r5 = nil
           end
           s0 << r5
           if r5
             r9 = _nt_w
             s0 << r9
             if r9
               i11, s11 = index, []
               if has_terminal?(":", false, index)
                 r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
                 @index += 1
               else
                 terminal_parse_failure(":")
                 r12 = nil
               end
               s11 << r12
               if r12
                 s13, i13 = [], index
                 loop do
                   if has_terminal?('\G[a-zA-Z]', true, index)
                     r14 = true
                     @index += 1
                   else
                     r14 = nil
                   end
                   if r14
                     s13 << r14
                   else
                     break
                   end
                 end
                 if s13.empty?
                   @index = i13
                   r13 = nil
                 else
                   r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                 end
                 s11 << r13
               end
               if s11.last
                 r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                 r11.extend(Substitution1)
               else
                 @index = i11
                 r11 = nil
               end
               if r11
                 r10 = r11
               else
                 r10 = instantiate_node(SyntaxNode,input, index...index)
               end
               s0 << r10
               if r10
                 r15 = _nt_w
                 s0 << r15
                 if r15
                   if has_terminal?(']', false, index)
                     r16 = instantiate_node(SyntaxNode,input, index...(index + 1))
                     @index += 1
                   else
                     terminal_parse_failure(']')
                     r16 = nil
                   end
                   s0 << r16
                 end
               end
             end
           end
         end
       end
     end
     if s0.last
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Substitution2)
       r0.extend(Substitution3)
     else
       @index = i0
       r0 = nil
     end

     node_cache[:substitution][start_index] = r0

     r0
   end

   module W0
				def confabulate(kb = nil)
					text_value
				end

				def tree(kb = nil)
				  confabulate(kb)
				end
   end

   def _nt_w
     start_index = index
     if node_cache[:w].has_key?(index)
       cached = node_cache[:w][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     s0, i0 = [], index
     loop do
       if has_terminal?('\G[ \\t]', true, index)
         r1 = true
         @index += 1
       else
         r1 = nil
       end
       if r1
         s0 << r1
       else
         break
       end
     end
     r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
     r0.extend(W0)

     node_cache[:w][start_index] = r0

     r0
   end

   module EscapedChar0
     def character
       elements[1]
     end
   end

   module EscapedChar1
				def confabulate(kb = nil)
					character.text_value
				end

				def tree(kb = nil)
				  confabulate(kb)
				end
   end

   def _nt_escaped_char
     start_index = index
     if node_cache[:escaped_char].has_key?(index)
       cached = node_cache[:escaped_char][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     i0, s0 = index, []
     if has_terminal?('\\', false, index)
       r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
       @index += 1
     else
       terminal_parse_failure('\\')
       r1 = nil
     end
     s0 << r1
     if r1
       if index < input_length
         r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
         @index += 1
       else
         terminal_parse_failure("any character")
         r2 = nil
       end
       s0 << r2
     end
     if s0.last
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(EscapedChar0)
       r0.extend(EscapedChar1)
     else
       @index = i0
       r0 = nil
     end

     node_cache[:escaped_char][start_index] = r0

     r0
   end

   module Words0
				def confabulate(kb = nil)
					text_value
				end
				
				def tree(kb = nil)
				  confabulate(kb)
				end
   end

   def _nt_words
     start_index = index
     if node_cache[:words].has_key?(index)
       cached = node_cache[:words][index]
       if cached
         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
         @index = cached.interval.end
       end
       return cached
     end

     s0, i0 = [], index
     loop do
       if has_terminal?('\G[^\\[{}`\\|\\\\]', true, index)
         r1 = true
         @index += 1
       else
         r1 = nil
       end
       if r1
         s0 << r1
       else
         break
       end
     end
     if s0.empty?
       @index = i0
       r0 = nil
     else
       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
       r0.extend(Words0)
     end

     node_cache[:words][start_index] = r0

     r0
   end

 end

 class ConfabulatorLanguageParser < Treetop::Runtime::CompiledParser
   include ConfabulatorLanguage
 end

end